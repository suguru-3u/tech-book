package org.example.良いコード悪いコード学ぶ設計入門.さまざまな悪魔達_9章

/**
 * 以下のようなコードは、思わぬバグを発生してしまう可能性があるので実装しない方がいい
 * 今は良くても機能拡張などで到達できるようになり、思わぬバグとなる可能性もある
 */

// デットコード
fun deadCode() {
    val x = 10
    if (x < 5) {
        // ここの処理は絶対に到達しない
    }
}

// YAGNI原則
// 将来を見越して機能を実装しても使われないことがほとんどだから、将来を見越して機能を開発する必要はなし

// マジックナンバー　⭐️
// いきなり数字が出てきても何をしているのか理解することができない。数字に変数で名前をつけてあげることでコードの可読性が上がる
fun magicNumber() {
    val price = 1000
    val totalPrice = price + (price * 0.1) // マジックナンバーを使用している
    println("Total Price: $totalPrice")
}

// 文字列型執着
// 単一のString変数に複数の値を格納してしまうとコードの柔軟性が失われる
val title = "タイトル,255,250,240,64";

// グローバル変数
// いつどこで変更されたのか把握することが難しくなるため、使用するスコープを限定することが望ましい

// null問題
// nullを許容すると思わぬバグを引き起こす可能性があるため、できるだけnullを使用しないようにする
// どうしてもnullを使用したいときは空文字などで代替え可能か検討を行う
// nullを返さない・渡さない

// 例外処理は握り潰してはいけない
// 適切に処理を行うべき

// メタプログラミング
// Kotlinではリフレクションを使用して、クラスや関数の情報を動的に取得することができるが、思わぬバグが発生する可能性があるため
// 使用する際はスコープを決めて使用すること

// パッケージ構成　⭐️
// controller, service, repository, modelなど技術的に同じカテゴリーにあるものをまとめるのを技術駆動パッケージという
// 逆にビジネスクラス同士をまとめてるのをビジネス駆動パッケージという。どちらかを言えば、ビジネス駆動パッケージの方が関連し合うクラスが密接になるので
// 管理しやすくなる